Anton_Korobeynikov.pdf:
isel = instruction selection!

. IR Level Passes
 ?- Late opts (LSR, elimination of dead BBs)
 ?- IR-level lowering: GC, EH, stack protector
   ?= EH lowering: lowering of EH intrinsics to unwinding runtime constructs (e.g. sjlj stuff)
 ?- Custom pre-isel passes
 ?- CodeGenPrepare
   ?= Addressing mode-related simplifications
   ?= Inline asm simplification (e.g. bswap patterns)
    = Move debug stuff closer to defs
. Selection DAG
  - First strictly backend IR
  - Even lower level than LLVM IR
 ?- Use-def chains + additional stuff to keep things in order
 ?- Built on pre-BB basis
 chain:
 ?- Lowering
 ?- Combine
   ?= Optimizations on DAG
    = Close to target
    = Runs twice - before and after legalize   
   ?= Used to cleanup / handle optimization opportunities exposed by targets
  - Legalize
   ?= Turn non-legal operations into legal one
   e.g.:
   ?= Software floating point
   ?= Scalarization of vectors
   ?= Widening of "funky" types (e.g. i42)
  - Combine
    = See previous
  - Instruction Selection
    = Turns SDAGs into MIs
   ?= Uses target-defined patterns to select instructions and operands
   ?= Does bunch of magic and crazy pattern-matching
   ?= Target can provide "fast but crude" isel for -O0 (fallbacks to standard one if cannot isel something)
. Machine
 ?- YA set of IR: MachineInst + MachineBB + MachineFunction
  - Close to target code
 ?- Pretty explicit: set of impdef regs, basic block live in / live out regs, etc.
  - Used as IR for all post-isel passes
. Register Allocation-relative
  - Pre-RA Passes
   ?= Pre-RA tail duplication
   ?= PHI optimization
   ?= MachineLICM, CSE, DCE
    = More peephole opts
   ?= Code still in SSA form
  - Register Allocator
    = Fast
    = Greedy (default)
   ?= PBQP
  - Post-RA Passes
   ?1. Prologue / Epilogue Insertion & Abstract Frame Indexes Elimination
   ?2. Branch Folding & Simplification
   ?3. Tail duplication
   ?4. Reg-reg copy propagation
   ?5. Post-RA scheduler
   ?6. BB placement to optimize hot paths
. Assembler Printing
 ?- Lower MI-level constructs to MCInst
 ?- Let MCStreamer decide what to do next: emit assembler, object file or binary code into memory
. Customization
 ?- Target can insert its own passes in specific points in the pipeline
 e.g.
 ?- IT(IR?) block formation, load-store optimization on ARM
  - Delay slot filling on MIPS or SPARC
. The Backend
  - Standalone library
  - Mixed C++ code + TableGen
 ?- TableGen is a special DSL used to describe register sets, calling conventions, instruction patterns, etc.
  - Inheritance and overloading are used to augment necessary target bits into target-independent codegen classes
. Stub Backend
  - 15 classes
  - around 1k LOC (C++ + TableGen)
  - FooTargetMachine
    = Central class in each backend
    = Glues (almost) all the backend classes
    = Controls the backend pipeline
  - FooSubtarget
    = Several "subtargets" inside one target
    = Usually used to model different instruction sets, platform-specific things, etc.
    = Done via "subtarget features"
  - FooRegisterInfo
    = Provides various info about reg sets:
      1. Callee saved regs
      2. Reserved (non-allocable) regs
     ?3. Register allocation order
     ?4. Register classes for cross-class copying & coalescing
    = Partly autogenerated from FooRegisterInfo.td
  - FooRegisterInfo.td
    = TableGen description of
      1. Registers,
      2. Sub-registers (and aliasing sets of regs)
      3. Register classes
 ?- FooISelLowering
   ?= Central class for target-aware lowering
   ?= Turns target-neutral SelectionDAG in target-aware (suitable for instruction selection)
   ?= Somethings can be lowered (albeit not efficiently) in generic way
   ?= Some cases (e.g. argument lowering) always require custom lowering
  - FooCallingConv.td
    = Describes the calling convention:
      1. What & where & in which order should be passed
      2. Not self-containing: used to simplify custom lowering routines
      3. Autogenerate set of callee-save registers
 - FooISelDAGToDAG
   = Does most of instruction selection
  ?= Most of C++ code is autogenerated from instruction patterns
   = Custom instruction selection code:
    ?+ Complex addressing modes
    ?+ Instructions which require additional care
 - FooInstrInfo
  ?= Hooks used by codegen to:
    ?1. Emit reg-reg copies
     2. Save / restore values on stack
    ?3. Branch-related operations
    ?4. Determine instruction sizes
 - FooInstrInfo.td
  ?= Defines the instruction patterns:
    ?1. DAG: level of input & output operands
    ?2. MI: Instruction Encoding
    ?3. ASM: Assembler printing strings
   = TableGen magic can autogenerate many things
 - FooFrameLowering
  ?= Hooks connected with function stack frames:
    ?1. Prologue & epilogue expansion
    ?2. Function call frame formation
    ?3. Spilling & restoring of callee saved regs
 - FooMCInstPrinter
   = Target part of generic assembler printing code
   = Specifies how a given MCInst should be represented as an assembler string:
     1. Instruction opcodes, operands
     2. Encoding of immediate values,
     3. Workarounds for assembler bugs :)
 - Others, not included
   = MC-level stuff: MC{Asm, Instr, Reg}Info
   = Assemblers and disassemblers
   = Direct object code emission
   = MI-level (post-RA) scheduler
. Example: see ../resourses/Anton_Korobeynikov.pdf
